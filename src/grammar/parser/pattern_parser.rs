// Generated by rust-peg. Do not edit.
#![allow(non_snake_case, unused)]
use matcher::compiled_pattern::{CompiledPattern, TokenType};
use parsers::{SetParser, IntParser, Parser, OptionalParameter, GreedyParser};
use grammar;
use utils;
use parsers::ParserFactory;
use std::str::FromStr;
use self::RuleResult::{Matched, Failed};
fn escape_default(s: &str) -> String {
    s.chars().flat_map(|c| c.escape_default()).collect()
}
fn char_range_at(s: &str, pos: usize) -> (char, usize) {
    let c = &s[pos..].chars().next().unwrap();
    let next_pos = pos + c.len_utf8();
    (*c, next_pos)
}
#[derive(Clone)]
enum RuleResult<T> {
    Matched(usize, T),
    Failed,
}
#[derive(PartialEq, Eq, Debug, Clone)]
pub struct ParseError {
    pub line: usize,
    pub column: usize,
    pub offset: usize,
    pub expected: ::std::collections::HashSet<&'static str>,
}
pub type ParseResult<T> = Result<T, ParseError>;
impl ::std::fmt::Display for ParseError {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::result::Result<(), ::std::fmt::Error> {
        try!(write!(fmt, "error at {}:{}: expected ", self.line, self.column));
        if self.expected.is_empty() {
            try!(write!(fmt, "EOF"));
        } else if self.expected.len() == 1 {
            try!(write!(fmt,
                        "`{}`",
                        escape_default(self.expected.iter().next().unwrap())));
        } else {
            let mut iter = self.expected.iter();
            try!(write!(fmt, "one of `{}`", escape_default(iter.next().unwrap())));
            for elem in iter {
                try!(write!(fmt, ", `{}`", escape_default(elem)));
            }
        }
        Ok(())
    }
}
impl ::std::error::Error for ParseError {
    fn description(&self) -> &str {
        "parse error"
    }
}
fn slice_eq(input: &str, state: &mut ParseState, pos: usize, m: &'static str) -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    let l = m.len();
    if input.len() >= pos + l && &input.as_bytes()[pos..pos + l] == m.as_bytes() {
        Matched(pos + l, ())
    } else {
        state.mark_failure(pos, m)
    }
}
fn slice_eq_case_insensitive(input: &str,
                             state: &mut ParseState,
                             pos: usize,
                             m: &'static str)
                             -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    let mut used = 0usize;
    let mut input_iter = input[pos..].chars().flat_map(|x| x.to_uppercase());
    for m_char_upper in m.chars().flat_map(|x| x.to_uppercase()) {
        used += m_char_upper.len_utf8();
        let input_char_result = input_iter.next();
        if input_char_result.is_none() || input_char_result.unwrap() != m_char_upper {
            return state.mark_failure(pos, m);
        }
    }
    Matched(pos + used, ())
}
fn any_char(input: &str, state: &mut ParseState, pos: usize) -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    if input.len() > pos {
        let (_, next) = char_range_at(input, pos);
        Matched(next, ())
    } else {
        state.mark_failure(pos, "<character>")
    }
}
fn pos_to_line(input: &str, pos: usize) -> (usize, usize) {
    let mut remaining = pos;
    let mut lineno: usize = 1;
    for line in input.lines() {
        let line_length = line.len() + 1;
        if remaining < line_length {
            return (lineno, remaining + 1);
        }
        remaining -= line_length;
        lineno += 1;
    }
    (lineno, remaining + 1)
}
struct ParseState<'input> {
    max_err_pos: usize,
    expected: ::std::collections::HashSet<&'static str>,
    _phantom: ::std::marker::PhantomData<&'input ()>,
}
impl <'input> ParseState<'input> {
    fn new() -> ParseState<'input> {
        ParseState {
            max_err_pos: 0,
            expected: ::std::collections::HashSet::new(),
            _phantom: ::std::marker::PhantomData,
        }
    }
    fn mark_failure(&mut self, pos: usize, expected: &'static str) -> RuleResult<()> {
        if pos > self.max_err_pos {
            self.max_err_pos = pos;
            self.expected.clear();
        }
        if pos == self.max_err_pos {
            self.expected.insert(expected);
        }
        Failed
    }
}
fn parse_pattern<'input, F: ParserFactory>(input: &'input str,
                                           state: &mut ParseState<'input>,
                                           pos: usize)
                                           -> RuleResult<CompiledPattern> {
    {
        let start_pos = pos;
        {
            let seq_res = {
                let mut repeat_pos = pos;
                let mut repeat_value = vec![];
                loop {
                    let pos = repeat_pos;
                    let step_res = parse_pattern_piece::<F>(input, state, pos);
                    match step_res {
                        Matched(newpos, value) => {
                            repeat_pos = newpos;
                            repeat_value.push(value);
                        }
                        Failed => {
                            break;
                        }
                    }
                }
                if repeat_value.len() >= 1usize {
                    Matched(repeat_pos, repeat_value)
                } else {
                    Failed
                }
            };
            match seq_res {
                Matched(pos, pieces) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos, {
                            let mut pieces = pieces;
                            utils::flatten_vec(pieces)
                        })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_pattern_piece<'input, F: ParserFactory>(input: &'input str,
                                                 state: &mut ParseState<'input>,
                                                 pos: usize)
                                                 -> RuleResult<Vec<TokenType>> {
    {
        let choice_res = parse_parser_GREEDY::<F>(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res = parse_piece_literal::<F>(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => parse_piece_parser::<F>(input, state, pos),
                }
            }
        }
    }
}
fn parse_piece_literal<'input, F: ParserFactory>(input: &'input str,
                                                 state: &mut ParseState<'input>,
                                                 pos: usize)
                                                 -> RuleResult<Vec<TokenType>> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_literal::<F>(input, state, pos);
            match seq_res {
                Matched(pos, literal) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos, {
                            let unescaped_literal = grammar::unescape_literal(literal);
                            vec![TokenType::Literal(unescaped_literal)]
                        })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_piece_parser<'input, F: ParserFactory>(input: &'input str,
                                                state: &mut ParseState<'input>,
                                                pos: usize)
                                                -> RuleResult<Vec<TokenType>> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_PARSER_BEGIN::<F>(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_parser::<F>(input, state, pos);
                        match seq_res {
                            Matched(pos, parser) => {
                                {
                                    let seq_res = parse_PARSER_END::<F>(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str = &input[start_pos..pos];
                                                Matched(pos, {
                                                    vec![TokenType::Parser(parser)]
                                                })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_parser<'input, F: ParserFactory>(input: &'input str,
                                          state: &mut ParseState<'input>,
                                          pos: usize)
                                          -> RuleResult<Box<Parser>> {
    {
        let choice_res = parse_parser_SET::<F>(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => parse_parser_INT::<F>(input, state, pos),
        }
    }
}
fn parse_parser_SET<'input, F: ParserFactory>(input: &'input str,
                                              state: &mut ParseState<'input>,
                                              pos: usize)
                                              -> RuleResult<Box<Parser>> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_SET::<F>(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_PARSER_PARAMS_BEGIN::<F>(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res = parse_string::<F>(input, state, pos);
                                    match seq_res {
                                        Matched(pos, set) => {
                                            {
                                                let seq_res =
                                                    match parse_parser_SET_optional_params::<F>(input,
                                                                                           state,
                                                                                           pos)
                                                        {
                                                        Matched(newpos, value)
                                                        => {
                                                            Matched(newpos,
                                                                    Some(value))
                                                        }
                                                        Failed => {
                                                            Matched(pos, None)
                                                        }
                                                    };
                                                match seq_res {
                                                    Matched(pos, opt_params) => {
                                                        {
                                                            let seq_res =
                                                                parse_PARSER_PARAMS_END::<F>(input,
                                                                                             state,
                                                                                             pos);
                                                            match seq_res {
                                                                Matched(pos, _) => {
                                                                    {
                                                                        let seq_res =
                                                                            match parse_parser_name::<F>(input,
                                                                                                    state,
                                                                                                    pos)
                                                                                {
                                                                                Matched(newpos,
                                                                                        value)
                                                                                =>
                                                                                {
                                                                                    Matched(newpos,
                                                                                            Some(value))
                                                                                }
                                                                                Failed
                                                                                =>
                                                                                {
                                                                                    Matched(pos,
                                                                                            None)
                                                                                }
                                                                            };
                                                                        match seq_res {
                                                                            Matched(pos, name) => {
                                                                                {
                                                                                    let match_str =
                                                                                        &input[start_pos..pos];
                                                                                    Matched(pos,
                                                                                            {
                                                                                                F::new_set(set,
                                                                                                           name,
                                                                                                           opt_params)
                                                                                            })
                                                                                }
                                                                            }
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_parser_SET_optional_params<'input, F: ParserFactory>
                                                              (input: &'input str,
                                                               state: &mut ParseState<'input>,
                                                               pos: usize)
                                                               -> RuleResult<Vec<OptionalParameter<'input>>> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_comma::<F>(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = {
                            let mut repeat_pos = pos;
                            let mut repeat_value = vec![];
                            loop {
                                let pos = repeat_pos;
                                let pos = if !repeat_value.is_empty() {
                                    let sep_res = parse_comma::<F>(input, state, pos);
                                    match sep_res {
                                        Matched(newpos, _) => {
                                            newpos
                                        }
                                        Failed => break,
                                    }
                                } else {
                                    pos
                                };
                                let step_res = parse_parser_BASE_optional_param::<F>(input,
                                                                                     state,
                                                                                     pos);
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                        repeat_value.push(value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            Matched(repeat_pos, repeat_value)
                        };
                        match seq_res {
                            Matched(pos, params) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, {
                                        params
                                    })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_parser_INT<'input, F: ParserFactory>(input: &'input str,
                                              state: &mut ParseState<'input>,
                                              pos: usize)
                                              -> RuleResult<Box<Parser>> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_INT::<F>(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = match parse_parser_INT_optional_params::<F>(input,
                                                                                  state,
                                                                                  pos) {
                            Matched(newpos, value) => {
                                Matched(newpos, Some(value))
                            }
                            Failed => {
                                Matched(pos, None)
                            }
                        };
                        match seq_res {
                            Matched(pos, opt_params) => {
                                {
                                    let seq_res = match parse_parser_name::<F>(input, state, pos) {
                                        Matched(newpos, value) => {
                                            Matched(newpos, Some(value))
                                        }
                                        Failed => {
                                            Matched(pos, None)
                                        }
                                    };
                                    match seq_res {
                                        Matched(pos, name) => {
                                            {
                                                let match_str = &input[start_pos..pos];
                                                Matched(pos, {
                                                    F::new_int(name, opt_params)
                                                })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_parser_INT_optional_params<'input, F: ParserFactory>
                                                              (input: &'input str,
                                                               state: &mut ParseState<'input>,
                                                               pos: usize)
                                                               -> RuleResult<Vec<OptionalParameter<'input>>> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_PARSER_PARAMS_BEGIN::<F>(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = {
                            let mut repeat_pos = pos;
                            let mut repeat_value = vec![];
                            loop {
                                let pos = repeat_pos;
                                let pos = if !repeat_value.is_empty() {
                                    let sep_res = parse_comma::<F>(input, state, pos);
                                    match sep_res {
                                        Matched(newpos, _) => {
                                            newpos
                                        }
                                        Failed => break,
                                    }
                                } else {
                                    pos
                                };
                                let step_res = parse_parser_BASE_optional_param::<F>(input,
                                                                                     state,
                                                                                     pos);
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                        repeat_value.push(value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            Matched(repeat_pos, repeat_value)
                        };
                        match seq_res {
                            Matched(pos, params) => {
                                {
                                    let seq_res = parse_PARSER_PARAMS_END::<F>(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str = &input[start_pos..pos];
                                                Matched(pos, {
                                                    params
                                                })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_parser_GREEDY<'input, F: ParserFactory>(input: &'input str,
                                                 state: &mut ParseState<'input>,
                                                 pos: usize)
                                                 -> RuleResult<Vec<TokenType>> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_PARSER_BEGIN::<F>(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_GREEDY::<F>(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res = match parse_parser_name::<F>(input, state, pos) {
                                        Matched(newpos, value) => {
                                            Matched(newpos, Some(value))
                                        }
                                        Failed => {
                                            Matched(pos, None)
                                        }
                                    };
                                    match seq_res {
                                        Matched(pos, name) => {
                                            {
                                                let seq_res = parse_PARSER_END::<F>(input,
                                                                                    state,
                                                                                    pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                match parse_literal::<F>(input,
                                                                                         state,
                                                                                         pos) {
                                                                    Matched(newpos, value) => {
                                                                        Matched(newpos, Some(value))
                                                                    }
                                                                    Failed => {
                                                                        Matched(pos, None)
                                                                    }
                                                                };
                                                            match seq_res {
                                                                Matched(pos, end_string) => {
                                                                    {
                                                                        let match_str =
                                                                            &input[start_pos..pos];
                                                                        Matched(pos,
                                                                                {
                                                                                    let mut tokens =
                                                                                        Vec::new();
                                                                                    let parser =
                                                                                        F::new_greedy(name,
                                                                                                      end_string);
                                                                                    tokens.push(TokenType::Parser(parser));
                                                                                    let end_string =
                                                                                        end_string.map(|string|
                                                                                                           string.to_owned());
                                                                                    if let Some(end_string)
                                                                                           =
                                                                                           end_string
                                                                                           {
                                                                                        tokens.push(TokenType::Literal(end_string));
                                                                                    }
                                                                                    tokens
                                                                                })
                                                                    }
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_parser_BASE_optional_param<'input, F: ParserFactory>
                                                              (input: &'input str,
                                                               state: &mut ParseState<'input>,
                                                               pos: usize)
                                                               -> RuleResult<OptionalParameter<'input>> {
    {
        let choice_res = {
            let start_pos = pos;
            {
                let seq_res = parse_MIN_LEN::<F>(input, state, pos);
                match seq_res {
                    Matched(pos, name) => {
                        {
                            let seq_res = slice_eq(input, state, pos, "=");
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let seq_res = parse_int::<F>(input, state, pos);
                                        match seq_res {
                                            Matched(pos, value) => {
                                                {
                                                    let match_str = &input[start_pos..pos];
                                                    Matched(pos, {
                                                        OptionalParameter::Int(name, value)
                                                    })
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    }
                    Failed => Failed,
                }
            }
        };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = parse_MAX_LEN::<F>(input, state, pos);
                    match seq_res {
                        Matched(pos, name) => {
                            {
                                let seq_res = slice_eq(input, state, pos, "=");
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res = parse_int::<F>(input, state, pos);
                                            match seq_res {
                                                Matched(pos, value) => {
                                                    {
                                                        let match_str = &input[start_pos..pos];
                                                        Matched(pos, {
                                                            OptionalParameter::Int(name, value)
                                                        })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_MIN_LEN<'input, F: ParserFactory>(input: &'input str,
                                           state: &mut ParseState<'input>,
                                           pos: usize)
                                           -> RuleResult<&'input str> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "min_len");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos, {
                            match_str
                        })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_MAX_LEN<'input, F: ParserFactory>(input: &'input str,
                                           state: &mut ParseState<'input>,
                                           pos: usize)
                                           -> RuleResult<&'input str> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "max_len");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos, {
                            match_str
                        })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_INT<'input, F: ParserFactory>(input: &'input str,
                                       state: &mut ParseState<'input>,
                                       pos: usize)
                                       -> RuleResult<&'input str> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "INT");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos, {
                            match_str
                        })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_SET<'input, F: ParserFactory>(input: &'input str,
                                       state: &mut ParseState<'input>,
                                       pos: usize)
                                       -> RuleResult<&'input str> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "SET");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos, {
                            match_str
                        })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_GREEDY<'input, F: ParserFactory>(input: &'input str,
                                          state: &mut ParseState<'input>,
                                          pos: usize)
                                          -> RuleResult<&'input str> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "GREEDY");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos, {
                            match_str
                        })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_PARSER_BEGIN<'input, F: ParserFactory>(input: &'input str,
                                                state: &mut ParseState<'input>,
                                                pos: usize)
                                                -> RuleResult<()> {
    slice_eq(input, state, pos, "%{")
}
fn parse_PARSER_END<'input, F: ParserFactory>(input: &'input str,
                                              state: &mut ParseState<'input>,
                                              pos: usize)
                                              -> RuleResult<()> {
    slice_eq(input, state, pos, "}")
}
fn parse_PARSER_PARAMS_BEGIN<'input, F: ParserFactory>(input: &'input str,
                                                       state: &mut ParseState<'input>,
                                                       pos: usize)
                                                       -> RuleResult<()> {
    slice_eq(input, state, pos, "(")
}
fn parse_PARSER_PARAMS_END<'input, F: ParserFactory>(input: &'input str,
                                                     state: &mut ParseState<'input>,
                                                     pos: usize)
                                                     -> RuleResult<()> {
    slice_eq(input, state, pos, ")")
}
fn parse_parser_name<'input, F: ParserFactory>(input: &'input str,
                                               state: &mut ParseState<'input>,
                                               pos: usize)
                                               -> RuleResult<&'input str> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, ":");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_identifier::<F>(input, state, pos);
                        match seq_res {
                            Matched(pos, name) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, {
                                        name
                                    })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_identifier<'input, F: ParserFactory>(input: &'input str,
                                              state: &mut ParseState<'input>,
                                              pos: usize)
                                              -> RuleResult<&'input str> {
    {
        let start_pos = pos;
        {
            let seq_res = if input.len() > pos {
                let (ch, next) = char_range_at(input, pos);
                match ch {
                    'a'...'z' | 'A'...'Z' | '_' | '.' => Matched(next, ()),
                    _ => state.mark_failure(pos, "[a-zA-Z_.]"),
                }
            } else {
                state.mark_failure(pos, "[a-zA-Z_.]")
            };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = {
                            let mut repeat_pos = pos;
                            loop {
                                let pos = repeat_pos;
                                let step_res = {
                                    let seq_res = if input.len() > pos {
                                        let (ch, next) = char_range_at(input, pos);
                                        match ch {
                                            'a'...'z' |
                                            '-' |
                                            'A'...'Z' |
                                            '0'...'9' |
                                            '_' |
                                            '.' => Matched(next, ()),
                                            _ => state.mark_failure(pos, "[a-z-A-Z0-9_.]"),
                                        }
                                    } else {
                                        state.mark_failure(pos, "[a-z-A-Z0-9_.]")
                                    };
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let assert_res = if input.len() > pos {
                                                    let (ch, next) = char_range_at(input, pos);
                                                    match ch {
                                                        '-' => Matched(next, ()),
                                                        _ => state.mark_failure(pos, "[-]"),
                                                    }
                                                } else {
                                                    state.mark_failure(pos, "[-]")
                                                };
                                                match assert_res {
                                                    Failed => Matched(pos, ()),
                                                    Matched(..) => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            Matched(repeat_pos, ())
                        };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, {
                                        match_str
                                    })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_string<'input, F: ParserFactory>(input: &'input str,
                                          state: &mut ParseState<'input>,
                                          pos: usize)
                                          -> RuleResult<&'input str> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\"");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_all_chars_until_quotation_mark::<F>(input, state, pos);
                        match seq_res {
                            Matched(pos, s) => {
                                {
                                    let seq_res = slice_eq(input, state, pos, "\"");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str = &input[start_pos..pos];
                                                Matched(pos, {
                                                    s
                                                })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_literal<'input, F: ParserFactory>(input: &'input str,
                                           state: &mut ParseState<'input>,
                                           pos: usize)
                                           -> RuleResult<&'input str> {
    {
        let start_pos = pos;
        {
            let seq_res = {
                let mut repeat_pos = pos;
                let mut repeat_value = vec![];
                loop {
                    let pos = repeat_pos;
                    let step_res = {
                        let seq_res = {
                            let assert_res = parse_PARSER_BEGIN::<F>(input, state, pos);
                            match assert_res {
                                Failed => Matched(pos, ()),
                                Matched(..) => Failed,
                            }
                        };
                        match seq_res {
                            Matched(pos, _) => {
                                any_char(input, state, pos)
                            }
                            Failed => Failed,
                        }
                    };
                    match step_res {
                        Matched(newpos, value) => {
                            repeat_pos = newpos;
                            repeat_value.push(value);
                        }
                        Failed => {
                            break;
                        }
                    }
                }
                if repeat_value.len() >= 1usize {
                    Matched(repeat_pos, ())
                } else {
                    Failed
                }
            };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos, {
                            match_str
                        })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_all_chars_until_quotation_mark<'input, F: ParserFactory>(input: &'input str,
                                                                  state: &mut ParseState<'input>,
                                                                  pos: usize)
                                                                  -> RuleResult<&'input str> {
    {
        let start_pos = pos;
        {
            let seq_res = {
                let mut repeat_pos = pos;
                let mut repeat_value = vec![];
                loop {
                    let pos = repeat_pos;
                    let step_res = {
                        let seq_res = {
                            let assert_res = slice_eq(input, state, pos, "\"");
                            match assert_res {
                                Failed => Matched(pos, ()),
                                Matched(..) => Failed,
                            }
                        };
                        match seq_res {
                            Matched(pos, _) => {
                                any_char(input, state, pos)
                            }
                            Failed => Failed,
                        }
                    };
                    match step_res {
                        Matched(newpos, value) => {
                            repeat_pos = newpos;
                            repeat_value.push(value);
                        }
                        Failed => {
                            break;
                        }
                    }
                }
                if repeat_value.len() >= 1usize {
                    Matched(repeat_pos, ())
                } else {
                    Failed
                }
            };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos, {
                            match_str
                        })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_comma<'input, F: ParserFactory>(input: &'input str,
                                         state: &mut ParseState<'input>,
                                         pos: usize)
                                         -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, ",");
        match seq_res {
            Matched(pos, _) => {
                {
                    let mut repeat_pos = pos;
                    loop {
                        let pos = repeat_pos;
                        let step_res = slice_eq(input, state, pos, " ");
                        match step_res {
                            Matched(newpos, value) => {
                                repeat_pos = newpos;
                            }
                            Failed => {
                                break;
                            }
                        }
                    }
                    Matched(repeat_pos, ())
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_int<'input, F: ParserFactory>(input: &'input str,
                                       state: &mut ParseState<'input>,
                                       pos: usize)
                                       -> RuleResult<usize> {
    {
        let start_pos = pos;
        {
            let seq_res = {
                let mut repeat_pos = pos;
                let mut repeat_value = vec![];
                loop {
                    let pos = repeat_pos;
                    let step_res = if input.len() > pos {
                        let (ch, next) = char_range_at(input, pos);
                        match ch {
                            '0'...'9' => Matched(next, ()),
                            _ => state.mark_failure(pos, "[0-9]"),
                        }
                    } else {
                        state.mark_failure(pos, "[0-9]")
                    };
                    match step_res {
                        Matched(newpos, value) => {
                            repeat_pos = newpos;
                            repeat_value.push(value);
                        }
                        Failed => {
                            break;
                        }
                    }
                }
                if repeat_value.len() >= 1usize {
                    Matched(repeat_pos, ())
                } else {
                    Failed
                }
            };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos, {
                            usize::from_str(match_str).ok().unwrap()
                        })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
pub fn pattern<F: ParserFactory>(input: &str) -> ParseResult<CompiledPattern> {
    let mut state = ParseState::new();
    if let Matched(pos, value) = parse_pattern::<F>(input, &mut state, 0) {
        if pos == input.len() {
            return Ok(value);
        }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError {
        line: line,
        column: col,
        offset: state.max_err_pos,
        expected: state.expected,
    })
}
